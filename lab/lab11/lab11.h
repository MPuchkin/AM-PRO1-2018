//
// Лабораторная №11. Динамические массивы. Обработка ошибок.
// lab11.h
//
#pragma once

typedef unsigned int uint;
const double precision = 1E-15;

// Ввод двумерного массива c клавиатуры
// Параметры:
//     m – указатель на начало массива,
//     rows – количество строк массива m,
//     cols – количество столбцов массива m.
void read_new(double** &m, uint &rows, uint &cols);

// Освобождение памяти занимаемой двумерным массивом
// Параметры:
//     m – указатель на начало массива,
//     rows – количество строк массива m,
//     cols – количество столбцов массива m.
void delete_matrix(double** &m, const uint rows, const uint cols = 0);

// Вывод матрицы на консоль
// Параметры:
//     m – указатель на начало массива,
//     rows – количество строк для вывода,
//     cols – количество элементов в строке.
void print(double const* const* m, const uint rows, const uint cols);

// Найти минимальное положительное значение в массиве
// Параметры:
//     a – указатель на начало массива,
//     size – количество элементов в массиве.
// Возвращаемое значение:
//     минимальное положительное значение в массиве.
// Если положительных значений в массиве нет, выбрасывает исключение char*.
double min_positive(const double *a, const uint size);

// Найти минимальное положительное значение в матрице
// Параметры:
//     m – указатель на начало массива,
//     rows – количество строк массива m,
//     cols – количество столбцов массива m.
// Возвращаемое значение:
//     минимальное положительное значение в матрице.
// Если положительных значений в матрице нет, выбрасывает исключение char*.
double min_positive(double const* const* m, const uint rows, const uint cols);

// Найти отношение сумм элементов на главной и побочной диагоналях матрицы.
// Параметры:
//     m – указатель на начало массива,
//     rows – количество строк массива m,
//     cols – количество столбцов массива m.
// Возвращаемое значение:
//     отношение сумм значений на главной и побочной диагоналях.
// Если сумма элементов побочной диагонали равна нолю, выбрасывает исключение char*.
double major_div_minor(double const* const* m, const uint rows, const uint cols);

// Аггрегатная функция над массивом вещественных чисел.
typedef double aggregate(const double*, const uint);

// Добавить в матрицу столбец, содержащий результаты вычисления заданной аггрегатной фнкции для каждой строки.
// Выделяет динамическую память!
// Параметры:
//     m – указатель на начало массива,
//     rows – количество строк массива m,
//     cols – количество столбцов массива m,
//     aggr – аггргатная функция.
// Результат:
//     m указывает на новую матрицу в последнем столбце которой содержится результат вычислнения aggr.
void append_col(double** &m, const uint rows, uint &cols, aggregate aggr);

// Предикат над массивом вещественных чисел
typedef bool condition(const double*, const uint);

// Удалить из матрицы строки, удволетворяющие заданному функцией условию.
// Выделяет динамическую память!
// Параметры:
//     m – указатель на начало массива,
//     rows – количество строк массива m,
//     cols – количество столбцов массива m,
//     cond – условие удаления строк.
// Результат:
//     m указывает на новую матрицу без строк, удволетворяющих условию cond.
void remove_rows(double** &m, uint &rows, const uint cols, condition cond);
